# TODO

- Delete "old_config" from protobuf definition & UI
- Address ASAN-detected memory leaks
  - `sro::navmesh::triangulation::NavmeshTriangulation::buildNavmeshForRegion`
- eventBroker.cpp:130 handle memory leak when destructed, events lost in handle function
- Get away from include & src directories in silkroad_lib
- It would be really nice to have a local list of known characters
- Add UI element to toggle packet logging to console
- Auto relogin when a character disconnects
- Ensure that no state machine does any work in its constructor
  - Bonus if we can guarantee it
- Remove StateMachineActiveTooLong event
- Remove StateMachineCreated/Destroyed in ctors/dtors
- Make StateMachine::name a virtual function
- Handle the case when state::machine::PickItem's target item is picked by someone else
- If `SequentialStateMachines` is here to stay, rename it as something like `StateMachineQueue`, to represent that once a contained state machine is complete, it is destroyed and removed from the queue
- Change silkroad_lib dir to sro and match the project, so that the include path looks the same as the namespace
- Create a "pvp ledger" which holds all PvpDescriptors. Rather than sending around copies of PvpDescriptors, we can instead share pointers into the ledger
- Additionally, add move constructors for state machines which take in vectors of items, like Walking or GmCommandSpawnAndPickItems
- In the construction of state machines, with its reference to Bot, register itself with the bot. This would make it so that I dont need to manually also write code in the Bot to hold & execute the state machine
- In the construction of state machines, also give a pointer to the parent state machine
  - With this, and a private overridden version of onUpdate, we can catch & rethrow exceptions giving a "stack trace" of which state machine we were in
- Consolidate `type_id::TypeId storage::Item::typeId()` and `TypeId type_id::getTypeId(const sro::pk2::ref::Item &item)`
- Reimplement some version of pathfinding in case a character disconnects while dead and ends up back in town
- Send pings so that if the client crashes, the character does not disconnect
- Stop passing around GameData and make it a global singleton. It is a constant set of data that lots of parts of the code need to access. There's no point in passing it around everywhere
- In the state machine which enables PVP, if it gets cancelled, start again
- In `SkillEngine::skillRemainingCooldown`, store the expected end of the skill's cooldown explicitly rather than querying the `EventBroker`
  - Implement a similar mechanism for items
- In `JaxInterface::initialize()`, call all XLA JITted at least once, so that no time is spent JITing during combat
- Handle any kind of teleportation (spawn & despawn) while pvping & preparing for pvp
- Fix bug in EventBroker where an event cannot unsubscribe from itself
- Move GameData & parsing to silkroad lib
- PR/issue to Tracy to not clutter the "<common/>" include path
- Add move ctor/ass for PacketContainer, this should remove an unecessary alloc when taking a packet from SilkroadSecurity::GetPacketToRecv()
- Move Proxy::ProcessPackets to properly triggered async wakeups, not a looping timer
- [Not sure about this one anymore] I think for command/skill tracking, a couple changes should be made
  - If a "command" is "queued", the packet does not tell us which command has actually been queued. Right now, we assume that it was the first in the queue, which would be the first one requested. In practice, based on which skill executes next, I'm seeing that it can actually be the most recently requested. To solve for this, I think we should actually move the entire pending queue contents over to the accepted queue. This kind of leaves a new problem though. We might move something which the server did not actually officially accept. This is handled in the next point.
  - Currently, when we see a skill begin, we look through our accepted command queue starting from the back (last "accepted" first). Once (and if) we find a matching skill, we remove everything in the queue before it (newer accepted commands). I think we should instead look in the opposite order. We should find the most recent queuing of that skill. Still, we would remove everything before it. This will result in fewer things being removed. This also solves for mistakes that result because of the above change. We'll probably be moving too many things into the accepted queue because of that change. However, here, we're trimming everything which we added excessively.
- Remove Entity's reference to WorldState once we have a more fine-grained concurrency protection
- Maybe use a more functional approach using JAX for training so that we dont need to lock mutexes for the models in JaxInterface
- In the UI, when sending requests, poll for reply rather than block on it. If polling fails, Hyperbot might've died immediately after our send. We should reset the socket and exit.
- ClientManagerInterface will be blocked on sending a heartbeat if the client manager is not running. If something else in the bot crashes, ClientManagerInterface cannot shut down. We should probably poll on recv and reconstruct the socket if it fails.
- Display state machine trees in UI
- Prevent any user input while pvping
- Figure out how the client knows about the remaining buff duration when a character spawns. Currently, the parsing of the spawn packet does not contain a cast time.
- Add debuffs to Observation
- Make sure that the agent is receiving:
  - Skill use failed because insufficient MP
  - Item use failed because trying to use item which does not exist
- In EnsureFullVitalsAndNoStatuses, we need to check if any of the potions/pills are on cooldown before constructing a UseItem state machine, or either wait on the cooldown in UseItem
- If login error code is 3, there is no way to rectify by trying again. We actually need to kill the client (server connection, actually), and restart it.
- When a state machine is done, we should pop blocked opcodes. As opposed to how we currently only pop blocked ones on destruction.
- We can get more pvp throughput if we pair characters which are completely ready to fight. For example, there might be 4 characters who are preparing to pvp: A, B, C, and D. A & B are set to fight each other and C & D also. If A and C are both stuck waiting for a couple minutes due to a long skill cooldown, all 4 are stuck idle. Instead, B and D might be able to fight against each other.